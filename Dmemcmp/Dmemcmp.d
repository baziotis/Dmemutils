/*
   Boost Software License - Version 1.0 - August 17th, 2003

   Permission is hereby granted, free of charge, to any person or organization
   obtaining a copy of the software and accompanying documentation covered by
   this license (the "Software") to use, reproduce, display, distribute,
   execute, and transmit the Software, and to prepare derivative works of the
   Software, and to permit third-parties to whom the Software is furnished to
   do so, all subject to the following:

   The copyright notices in the Software and this entire statement, including
   the above license grant, this restriction and the following disclaimer,
   must be included in all copies of the Software, in whole or in part, and
   all derivative works of the Software, unless such copies or derivative
   works are solely in the form of machine-executable object code generated by
   a source language processor.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
*/


import std.traits : isArray;

int Dmemcmp(T)(ref T s1, ref T s2) @trusted
if(!isArray!T)
{
    const byte[] s1b = (cast(const(byte)*)&s1)[0 .. T.sizeof];
    const byte[] s2b = (cast(const(byte)*)&s2)[0 .. T.sizeof];
    return Dmemcmp(s1b, s2b);
}

int Dmemcmp(T)(const T[] s1, const T[] s2) @safe
{
    // That cast is always @safe and always can happen (because `byte` has size 1
    // and divides evenly every size).
    const byte[] s1b = (cast(const(byte[]))s1)[0 .. s1.length * T.sizeof];
    const byte[] s2b = (cast(const(byte[]))s2)[0 .. s2.length * T.sizeof];
    return Dmemcmp(s1b, s2b);
}

/* Static Arrays
 */
//int Dmemcmp(T, size_t len)(ref const T[len] s1, ref const T[len] s2) @safe pure
int Dmemcmp(T, size_t len)(ref const T[len] s1, ref const T[len] s2)
{
    // That cast is always @safe and always can happen (because `byte` has size 1
    // and divides evenly every size).
    const byte[] s1b = (cast(const(byte[]))s1)[0 .. len * T.sizeof];
    const byte[] s2b = (cast(const(byte[]))s2)[0 .. len * T.sizeof];
    return Dmemcmp(s1b, s2b);
}

/* Core tests
 */
unittest
{
    const byte[] a = [1, 2, 3];
    const byte[] b = [1, 2, 3];
    assert(Dmemcmp(a, b) == 0);
}

unittest
{
    const byte[] a = [1, 2, 3];
    const byte[] b = [1, 2, 2];
    assert(Dmemcmp(a, b) > 0);
}

unittest
{
    const byte[] a = [1, 2, 3];
    const byte[] b = [1, 3, 3];
    assert(Dmemcmp(a, b) < 0);
}

/* Make clear that the comparison is byte-byte and
 * not dependent on the type.
 */
unittest
{
    // Note: Every 2 digits in a hex is a byte.
    const uint[] a = [0x2030];
    const uint[] b = [0x1040];
    assert(a[0] > b[0]);
    assert(Dmemcmp(a, b) < 0);
}

@safe unittest
{
    long a = 10;
    long b = 20;
    assert(Dmemcmp(a, b) < 0);
}

/* More complicated correctness tests
 */

// NOTE(stefanos): The tests set the bytes in reverse
// because memcmp() stops on the first difference.

/// size % 16 == 0
unittest
{
    byte[128] a;
    byte[128] b;
    foreach (i ; 0 .. 128)
    {
        a[i] = b[i] = cast(byte)i;
    }
    a[97] = 4;
    assert(Dmemcmp(a, b) == -93);  // = 4 - 97
    a[35] = 89;
    assert(Dmemcmp(a, b) == 54);  // = 89 - 54
}

/// size % 16 == 1
unittest
{
    byte[1] a;
    byte[1] b;
    // 1st byte
    a[0] = 3;
    assert(Dmemcmp(a, b) == 3);  // = 3 - 0
    // 17 = 16 + 1, meaning it should test first in strides
    // of 16 and then one of 1.
    byte[17] c;
    byte[17] d;
    foreach (i ; 0 .. 17)
    {
        c[i] = d[i] = cast(byte)i;
    }
    // 17th byte
    c[16] = 2;
    assert(Dmemcmp(c, d) == -14);  // = 2 - 16
}

/// size % 16 == 2
unittest
{
    byte[2] a;
    byte[2] b;
    foreach (i ; 0 .. 2)
    {
        a[i] = b[i] = cast(byte)i;
    }
    // 2nd byte
    a[1] = 2;
    assert(Dmemcmp(a, b) == 1);  // = 2 - 1
    // 1st byte
    a[0] = 2;
    assert(Dmemcmp(a, b) == 2);  // = 2 - 0
    // 18 = 16 + 2, meaning it should test first in strides
    // of 16 and then one of 2.
    byte[18] c;
    byte[18] d;
    foreach (i ; 0 .. 18)
    {
        c[i] = d[i] = cast(byte)i;
    }
    // 18th byte
    c[17] = 2;
    assert(Dmemcmp(c, d) == -15);  // = 2 - 17
    // 17th byte
    c[16] = 2;
    assert(Dmemcmp(c, d) == -14);  // = 2 - 16
}

/// size % 16 == 4
unittest
{
    byte[4] a;
    byte[4] b;
    foreach (i; 0 .. 4)
    {
        a[i] = b[i] = cast(byte)i;
    }
    foreach_reverse(i; 0 .. 4)
    {
        a[i] = 10;
        assert(Dmemcmp(a, b) == (10 - i));
    }
    // 20 = 16 + 4, meaning it should test first in strides
    // of 16 and then one of 4.
    byte[20] c;
    byte[20] d;
    foreach (i ; 0 .. 20)
    {
        c[i] = d[i] = cast(byte)i;
    }
    foreach_reverse(i; 16 .. 20)
    {
        c[i] = 2;
        assert(Dmemcmp(c, d) == (2 - i));
    }
}

/// size % 16 == 8
unittest
{
    byte[8] a;
    byte[8] b;
    foreach (i; 0 .. 8)
    {
        a[i] = b[i] = cast(byte)i;
    }
    foreach_reverse(i; 0 .. 8)
    {
        a[i] = 10;
        assert(Dmemcmp(a, b) == (10 - i));
    }
    // 24 = 16 + 8, meaning it should test first in strides
    // of 16 and then one of 8.
    byte[24] c;
    byte[24] d;
    foreach (i ; 0 .. 24)
    {
        c[i] = d[i] = cast(byte)i;
    }
    foreach_reverse(i; 16 .. 24)
    {
        c[i] = 2;
        assert(Dmemcmp(c, d) == (2 - i));
    }
}

version (D_SIMD)
{
    import core.simd : float4;
    enum useSIMD = true;
}
else version (LDC)
{
    // LDC always supports SIMD (but doesn't ever set D_SIMD) and
    // the back-end uses the most appropriate size for every target.
    import core.simd : float4;
    enum useSIMD = true;
}
else version (GNU)
{
    import core.simd: float4;
    // GNU does not support SIMD by default.
    version (X86_64)
    {
        enum isX86 = true;
    }
    else version (X86)
    {
        enum isX86 = true;
    }

    static if (isX86 && __traits(compiles, float4))
    {
        enum useSIMD = true;
    }
    else
    {
        enum useSIMD = false;
    }
}
else
{
    enum useSIMD = false;
}

static if (useSIMD)
{
    /* SIMD implementation
     */
    //int Dmemcmp(ref const byte[] s1, ref const byte[] s2) @safe pure
    import core.simd : byte16;
    static string assign(string dst, string src)()
    {
        import std.conv : text;
        string res;
        foreach (j; 0 .. 16)
        {
            res ~= dst~"["~text(j)~"] = "~src~"[i*16+"~text(j)~"];";
        }
        return res;
    }

    version(LDC)
    {
        import ldc.gccbuiltins_x86 : __builtin_ia32_pmovmskb128;
        /// If a pair of bytes are equal, set the byte on the output to all 1s otherwise all 0s.
        byte16 cmpMask(byte16 a, byte16 b) pure @safe
        {
            byte16 res;
            foreach(i; 0 .. 16)
            {
                res.array[i] = cast(byte)((a[i] == b[i]) ? 0xffff : 0);
            }
            return res;
        }
        /// Put the most significat bit of each byte (so 16 bits for XMM) and put it to the lowest
        /// bits of return value.
        alias moveMask = __builtin_ia32_pmovmskb128;
    }
    else version(DigitalMars)
    {
        import core.simd : simd, XMM;
        /// If a pair of bytes is equal, set the byte on the output to all 1s (so -1), otherwise all 0s.
        alias cmpMask = simd!(XMM.PCMPEQB, byte16, byte16);
        /// Put the most significat bit of each byte (so 16 bits for XMM) and put it to the lowest
        /// bits of return value.
        uint moveMask(byte16 v) pure @safe
        {
            uint res = 0;
            foreach(bit; 0 .. 16)
            {
                if (v[bit] & 0b10000000) res |= (1 << bit);
            }
            return res;
        }
    }
    else
    {
        import gcc.builtins : __builtin_ia32_pcmpeqb128, __builtin_ia32_pmovmskb128;
        import core.simd : ubyte16;
        byte16 cmpMask(byte16 s1, byte16 s2) pure @safe
        {
            return cast(byte16) __builtin_ia32_pcmpeqb128(cast(ubyte16) s1, cast(ubyte16) s2);
        }
        int moveMask(byte16 v) pure @safe
        {
            return __builtin_ia32_pmovmskb128(cast(ubyte16) v);
        }
    }

    string bigStride(size_t stride)()
    {
        import std.conv : text;
        enum s = text(stride);
        return
        "
        {
            byte16 a, b;
            a.array[0 .. "~s~"] = s1[i .. i+"~s~"];
            b.array[0 .. "~s~"] = s2[i .. i+"~s~"];
            byte16 cmp = cmpMask(a, b);
            // lower the results to the least significant bytes
            uint lowered = moveMask(cmp);
            // \"Reverse\" the result so that we can do `bsf` then.
            uint diff = lowered ^ 0xffff;
            if(diff)
            {
                import core.bitop : bsf;
                int pos = bsf(diff);
                return a[pos] - b[pos];
            }
            i += "~s~";
            n -= "~s~";
        }
        ";
    }

    // IMPORTANT(stefanos): `byte` is used to notify the reader that
    // we use signed operations. These are subtractions. However, note
    // that due to integer promotion, the two operands of the subtractions
    // are first converted to `int` and then the subtraction is done.

    int Dmemcmp(ref const byte[] s1, ref const byte[] s2) @safe
    {
        assert(s1.length == s2.length);
        size_t n = s1.length;
        size_t i = 0;
        while (n >= 16) mixin(bigStride!(16)());
        if (n >= 8) mixin(bigStride!(8)());
        if (n >= 4) mixin(bigStride!(4)());
        if (n >= 2)
        {
            byte a = s1[i];
            byte b = s2[i];
            int diff = a - b;
            if (diff) return diff;
            a = s1[i+1];
            b = s2[i+1];
            diff = a - b;
            if (diff) return diff;
            i += 2;
            n -= 2;
        }
        if (n)
        {
            int diff = s1[i] - s2[i];
            return diff;
        }
        return 0;
    }
}
else
{
    int Dmemcmp(ref const byte[] s1, ref const byte[] s2) pure @safe
    {
        assert(s1.length == s2.length);
        foreach(i; 0 .. s1.length)
        {
            int diff = s1[i] - s2[i];
            if (diff) return diff;
        }
        return 0;
    }
}
